## 资源访问
网站的资源文件访问不会影响正常的操作访问，只有当访问的资源文件不存在的时候才会解析到入口文件，一般就会提示模块不存在的错误。

网站的资源文件一般放入public目录的子目录下面，例如下面是一个建议规范：
```php
public
├─index.php       应用入口文件
├─static				静态资源目录   
│  ├─css      样式目录
│  ├─js         脚本目录
│  └─img      图像目录
记住，千万不要在public目录之外的任何位置放置资源文件，包括application目录。
```

## 资源文件的起始位置  phpinfo()在页面输出中查看DOCUMENT_ROOT的值
网站的入口文件就是资源文件的起始位置，如果你的入口文件不是在public目录下面的话，还需要自行调整。
如果不清楚当前的入口文件位置，可以使用phpinfo()在页面输出中查看DOCUMENT_ROOT的值。

http://tp5study.com/phpinfo.php

## （9）视图
https://www.kancloud.cn/thinkphp/thinkphp5_quickstart/478276

###二、URL和路由
##（1）URL访问
下面是一个标准的URL访问格式：
http://domainName/index.php/模块/控制器/操作
---

模块在ThinkPHP中的概念其实就是应用目录下面的子目录，而官方的规范是目录名小写，
因此模块全部采用小写命名，无论URL是否开启大小写转换，模块名都会强制小写。

---
如果你的控制器是驼峰的，例如定义一个HelloWorld控制器（application/index/controller/HelloWorld.php）：

正确的URL访问地址（该地址可以使用url方法生成）应该是：

http://tp5.com/index.php/index/hello_world/index

##（3）隐藏入口

隐藏index.php
可以去掉URL地址里面的入口文件index.php，但是需要额外配置WEB服务器的重写规则。

以Apache为例，需要在入口文件的同级添加.htaccess文件（官方默认自带了该文件），内容如下：

<IfModule mod_rewrite.c>
Options +FollowSymlinks -Multiviews
RewriteEngine on
RewriteCond %{REQUEST_FILENAME} !-d
RewriteCond %{REQUEST_FILENAME} !-f
RewriteRule ^(.*)$ index.php/$1 [QSA,PT,L]
</IfModule>

##（4）定义路由

提示：
注意路由配置不支持在模块配置文件中设置。


添加如下路由规则：

return [
'blog/:year/:month' => ['blog/archive', ['method' => 'get'], ['year' => '\d{4}', 'month' => '\d{2}']],
'blog/:id'          => ['blog/get', ['method' => 'get'], ['id' => '\d+']],
'blog/:name'        => ['blog/read', ['method' => 'get'], ['name' => '\w+']],
];
在上面的路由规则中，我们对变量进行的规则约束，变量规则使用正则表达式进行定义。

我们看下几种URL访问的情况

// 访问id为5的内容
http://tp5.com/blog/5
// 访问name为thinkphp的内容
http://tp5.com/blog/thinkphp
// 访问2015年5月的归档内容
http://tp5.com/blog/2015/05
路由分组
上面的三个路由规则由于都是blog打头，所以我们可以做如下的简化：

return [
'[blog]' => [
':year/:month' => ['blog/archive', ['method' => 'get'], ['year' => '\d{4}', 'month' => '\d{2}']],    
':id'          => ['blog/get', ['method' => 'get'], ['id' => '\d+']],
':name'        => ['blog/read', ['method' => 'get'], ['name' => '\w+']],
],
];
对于这种定义方式，我们称之为路由分组，路由分组一定程度上可以提高路由检测的效率。


##（5）URL生成

// 输出 blog/thinkphp
Url::build('blog/read', 'name=thinkphp');
Url::build('blog/read', ['name' => 'thinkphp']);
// 输出 blog/5
Url::build('blog/get', 'id=5');
Url::build('blog/get', ['id' => 5]);
// 输出 blog/2015/05
Url::build('blog/archive', 'year=2015&month=05');
Url::build('blog/archive', ['year' => '2015', 'month' => '05']);

我们还可以使用系统提供的助手函数url来简化
url('blog/read', 'name=thinkphp');
// 等效于
Url::build('blog/read', 'name=thinkphp');

我们掌握的路由功能还只是ThinkPHP5.0路由功能的冰山一角，以后我们还会通过更多的专题来讲解路由。

###（三）：请求和响应
ThinkPHP5的Request对象由think\Request类完成。

Request对象的一个主要职责是统一和更安全地获取当前的请求信息，你需要避免直接操作$_GET、$_POST、$_REQUEST、$_SESSION、$_COOKIE，甚至$_FILES等全局变量，而是统一使用Request对象提供的方法来获取请求变量。

##（1）请求对象

动态绑定属性
可以给Request请求对象绑定属性，方便全局调用，例如我们可以在公共控制器中绑定当前登录的用户模型到请求对象：

<?php
namespace app\index\controller;

use app\index\model\User;
use think\Controller;
use think\Request;
use think\Session;

class Base extends Controller
{
    public function _initialize()
    {
    	$user = User::get(Session::get('user_id'));
		Request::instance()->bind('user',$user);
    }
}

